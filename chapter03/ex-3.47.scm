(define (make-mutex)
  (let ((cell (list #f)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire)))
            ((eq? m 'release)
             (clear! cell))))
    the-mutex))
(define (clear! cell)
  (set-car! cell #f))
(define (test-and-set! cell)
  (if (car cell)
      #t
      (begin (set-car! cell #t)
             #f)))

;; a. in terms of mutexes
(define (make-semaphore-a n)
  (let ((lock (make-mutex))
        (num-acquired 0))
    (define (lock-and-acquire!)
      (begin (lock 'acquire)
             (if (< num-acquired n)
                 (begin (set! num-acquired (+ num-acquired 1))
                        (lock 'release)
                        true)
                 (begin (lock 'release)
                        false))))
    (define (lock-and-release!)
      (begin (lock 'acquire)
             (if (> num-acquired 0)
                 (set! num-acquired (- num-acquired 1)))
             (lock 'release)))
    (define (the-semaphore m)
      (cond ((eq? m 'acquire)
             (if (not (lock-and-acquire!))
                 (the-semaphore 'acquire)))
            ((eq? m 'release)
             (lock-and-release!))))
    the-semaphore))

;; b. in terms of atomic test-and-set! operations
(define (make-semaphore-b n)
  (let ((cells (make-list n #f)))
    (define (test-and-set-list! cells)
      (cond ((empty? cells) #f)
            ((test-and-set! (car cells))
             (test-and-set-list! (cdr cells)))
            (else #t)))
    (define (clear-one! cells)
      (cond ((empty? cells) (void))
            ((car cells) (clear! cells))
            (else (clear-one! (cdr cells)))))
    (define (the-semaphore m)
      (cond ((eq? m 'acquire)
             (if (not (test-and-set-list! cells))
                 (the-semaphore 'acquire)))
            ((eq? m 'release)
             (clear-one! cells))))
    the-semaphore))
