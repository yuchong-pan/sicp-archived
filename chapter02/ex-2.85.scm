(define (install-project-package)
  (put 'project '(complex) (lambda (x)
                             (make-real (real-part x))))
  (put 'project '(real) (lambda (x)
                          (make-rational (inexact->exact (round x)) 1)))
  (put 'project '(rational) (lambda (x)
                              (make-integer (quotient (numer x) (denom x)))))
  'done)
(define (project x)
  (apply-generic 'project x))

(define (install-equ?-package)
  (put 'equ? '(integer integer) =)
  (put 'equ? '(rational rational) (lambda (x y)
                                    (let ((nx (numer x))
                                          (dx (denom x))
                                          (ny (numer y))
                                          (dy (denom y)))
                                      (and (= nx ny) (= dx dy)))))
  (put 'equ? '(real real) =)
  (put 'equ? '(complex complex) (and (= (real-part x) (real-part y))
                                     (= (imag-part x) (imag-part y))))
  'done)
(define (equ? x y)
  (apply-generic 'equ? x y))

(define (drop x)
  (cond ((eq? (type-tag x) 'integer) x)
        ((equ? (raise (project x)) x) (drop (project x)))
        (else x)))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (drop (apply proc (map contents args)))
          (if (= (length args) 2)
              (let ((a1 (car args))
                    (a2 (cadr args)))
                (let ((type1 (type-tag a1))
                      (type2 (type-tag a2)))
                  (cond ((eq? type1 type2) (error "No method for these types" (list op type-tags)))
                        ((higher? type1 type2) (apply-generic op a1 (raise a2)))
                        (else (apply-generic op (raise a1) a2)))))
              (error "No method for these types" (list op type-tags)))))))
