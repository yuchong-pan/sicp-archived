(define *op-table* (make-hash-table))
(define (put op type proc)
  (hash-table/put! *op-table* (list op type) proc))
(define (get op type)
  (hash-table/get *op-table* (list op type) #f))

(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'negation '(scheme-number) (lambda (x)  (tag (- x))))
  (put '=zero? '(scheme-number) (lambda (x) (= x 0)))
  (put 'greatest-common-divisor '(scheme-number scheme-number) (lambda (x y) (tag (gcd x y))))
  'done)
(define (make-scheme-number x)
  ((get 'make 'scheme-number) x))

(define (install-polynomial-package)
  (define (make-poly var terms) (cons var terms))
  (define (variable poly) (car poly))
  (define (term-list poly) (cdr poly))
  (define (same-variable e1 e2)
    (and (variable? e1)
         (variable? e2)
         (eq? e1 e2)))
  (define (variable? e) (symbol? e))
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))
  (define (sub-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (sub-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- SUB-POLY" (list p1 p2))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))
  (define (div-poly p1 p2)
    (if (same-variable? (variable p1)
                        (variable p2))
        (let ((terms (div-terms (term-list p1)
                                (term-list p2))))
          (list (make-poly (variable p1)
                           (car terms))
                (make-poly (variable p2)
                           (cadr terms))))
        (error "Polys not in same var -- DIV-POLY" (list p1 p2))))
  (define (add-terms l1 l2)
    (cond ((empty-termlist? l1) l2)
          ((empty-termlist? l2) l1)
          (else (let ((t1 (first-term l1))
                      (t2 (first-term l2)))
                  (cond ((< (order t1) (order t2))
                         (adjoin-term t2
                                      (add-terms l1 (rest-terms l2))))
                        ((> (order t1) (order t2))
                         (adjoin-term t1
                                      (add-terms (rest-terms l1) l2)))
                        (else (adjoin-term (make-term (order t1)
                                                      (add (coeff t1)
                                                           (coeff t2)))
                                           (add-terms (rest-terms l1)
                                                      (rest-terms l2)))))))))
  (define (sub-terms l1 l2)
    (cond ((empty-termlist? l1) (negation-termlist l2))
          ((empty-termlist? l2) l1)
          (else (let ((t1 (first-term l1))
                      (t2 (first-term l2)))
                  (cond ((< (order t1) (order t2))
                         (adjoin-term (negation-term t2)
                                      (sub-terms l1 (rest-terms l2))))
                        ((> (order t1) (order t2))
                         (adjoin-term t1
                                      (sub-terms (rest-terms l1) l2)))
                        (else (adjoin-term (make-term (order t1)
                                                      (sub (coeff t1)
                                                           (coeff t2)))
                                           (sub-terms (rest-terms l1)
                                                      (rest-terms l2)))))))))
  (define (negation-term term)
    (make-term (order term)
               (negation (coeff term))))
  (define (negation-termlist terms)
    (map (lambda (term) (negation-term term)) terms))
  (define (negation-poly p)
    (make-poly (variable p)
               (negation-termlist (term-list p))))
  (define (mul-terms l1 l2)
    (if (empty-termlist? l1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term l1) l2)
                   (mul-terms (rest-terms l1) l2))))
  (define (mul-term-by-all-terms t1 t)
    (if (empty-termlist? t)
        (the-empty-termlist)
        (let ((t2 (first-term t)))
          (adjoin-term (make-term (+ (order t1) (order t2))
                                  (mul (coeff t1) (coeff t2)))
                       (mul-term-by-all-terms t1 (rest-terms t))))))
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       (div-terms (sub-terms L1
                                             (mul-terms L2
                                                        (adjoin-term (make-term new-o new-c)
                                                                     (the-empty-termlist))))
                                  L2)))
                  (list (adjoin-term (make-term new-o new-c)
                                     (car rest-of-result))
                        (cadr rest-of-result))))))))
  (define (gcd-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (gcd-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- GCD-POLY" (list p1 p2))))
  (define (remainder-terms x y)
    (cadr (div-terms x y)))
  (define (gcd-terms a b)
    (if (empty-termlist? a)
        (display "0")
        (print-termlist a))
    (display " ***  ")
    (if (empty-termlist? b)
        (display "0")
        (print-termlist b))
    (newline)
    (let ((result (if (empty-termlist? b)
                      a
                      (gcd-terms b (pseudoremainder-terms a b)))))
      (let ((g (apply gcd (map (lambda (term)
                                 (contents (coeff term)))
                               result))))
        (map (lambda (term)
               (make-term (order term)
                          (/ (contents (coeff term)) g)))
             result))))
  (define (pseudoremainder-terms x y)
    (let ((c (contents (coeff (first-term y))))
          (o1 (order (first-term x)))
          (o2 (order (first-term y))))
      (let ((integerizing-factor (expt c (+ 1 o1 (- o2)))))
        (remainder-terms (mul-terms (adjoin-term (make-term 0 integerizing-factor)
                                                 (the-empty-termlist))
                                    x)
                         y))))
  (define (print-termlist terms)
    (cond ((not (null? terms)) (print-term (first-term terms))
                               (display " ")
                               (print-termlist (rest-terms terms)))))
  (define (print-term term)
    (display (if (positive? (contents (coeff term))) "+" ""))
    (display (contents (coeff term)))
    (cond ((positive? (contents (order term))) (display "x^")
                                               (display (order term)))))
  (define (tag x) (attach-tag 'polynomial x))
  (put 'add '(polynomial polynomial) (lambda (x y) (tag (add-poly x y))))
  (put 'mul '(polynomial polynomial) (lambda (x y) (tag (mul-poly x y))))
  (put 'div '(polynomial polynomial) (lambda (x y) (list (tag (car (div-poly x y)))
                                                         (tag (cadr (div-poly x y))))))
  (put 'negation '(polynomial) (lambda (x) (tag (negation-poly x))))
  (put 'make 'polynomial (lambda (x y) (tag (make-poly x y))))
  (put '=zero? '(polynomial) (lambda (x) (empty-termlist? x)))
  (put 'greatest-common-divisor '(polynomial polynomial) (lambda (x y) (tag (gcd-poly x y))))
  'done)
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
(define (add x y)
  (apply-generic 'add x y))
(define (sub x y)
  (apply-generic 'sub x y))
(define (mul x y)
  (apply-generic 'mul x y))
(define (div x y)
  (apply-generic 'div x y))
(define (negation x)
  (apply-generic 'negation x))
(define (=zero? x)
  (apply-generic '=zero? x))
(define (greatest-common-divisor x y)
  (apply-generic 'greatest-common-divisor x y))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error "No method for these types" (list op type-tags))))))
(define (attach-tag type-tag contents) (cons type-tag contents))
(define (type-tag x)
  (if (number? x)
      'scheme-number
      (car x)))
(define (contents x)
  (if (number? x)
      x
      (cdr x)))

(define (same-variable? x y)
  (and (variable? x)
       (variable? y)
       (eq? x y)))
(define (variable? x) (symbol? x))

(install-scheme-number-package)
(install-polynomial-package)
